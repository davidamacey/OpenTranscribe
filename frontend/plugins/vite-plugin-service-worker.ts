import type { Plugin } from "vite";
import { promises as fs } from "fs";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";

const CACHE_NAME = "transcribe-app-cache-v1";
const ASSETS_TO_CACHE = [
  "/",
  "/index.html",
  "/global.css",
  "/build/bundle.css",
  "/build/bundle.js",
  "/fonts/Poppins-Light.woff2",
  "/fonts/Poppins-Regular.woff2",
  "/fonts/Poppins-Medium.woff2",
  "/fonts/Poppins-SemiBold.woff2",
  "/fonts/Poppins-Bold.woff2",
  "/favicon.ico",
  "/favicon.svg",
];

export default function serviceWorkerPlugin(): Plugin {
  return {
    name: "vite-plugin-service-worker",
    apply: "build",
    async writeBundle() {
      const __filename = fileURLToPath(import.meta.url);
      const __dirname = dirname(__filename);

      const swSource = resolve(
        __dirname,
        "../src/lib/registerServiceWorker.ts",
      );
      const swDest = resolve(__dirname, "../dist/service-worker.js");

      // Ensure the directory exists
      await fs.mkdir(dirname(swDest), { recursive: true });

      // Read the service worker content
      let content = `// Service Worker - Auto-generated by Vite
// Generated at: ${new Date().toISOString()}

const CACHE_NAME = '${CACHE_NAME}';
const ASSETS_TO_CACHE = ${JSON.stringify(ASSETS_TO_CACHE, null, 2)};

// Install event - cache all static assets
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        return cache.addAll(ASSETS_TO_CACHE);
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => name !== CACHE_NAME)
          .map((name) => caches.delete(name))
      );
    })
  );
});

// Fetch event - serve from cache, falling back to network
self.addEventListener('fetch', (event) => {
  const request = event.request;

  // Skip non-GET requests and chrome-extension URLs
  if (request.method !== 'GET' || request.url.startsWith('chrome-extension://')) {
    return;
  }

  // Handle API requests
  if (request.url.includes('/api/')) {
    // For API requests, try network first, then fall back to cache if offline
    event.respondWith(
      fetch(request)
        .then((response) => {
          // Clone the response to save it to cache
          const responseToCache = response.clone();
          caches.open(CACHE_NAME)
            .then((cache) => {
              cache.put(request, responseToCache);
            });
          return response;
        })
        .catch(() => {
          // If network fails, try to get from cache
          return caches.match(request);
        })
    );
  } else {
    // For static assets, try cache first, then network
    event.respondWith(
      (async () => {
        const cachedResponse = await caches.match(request);
        // Return cached response if found
        if (cachedResponse) {
          return cachedResponse;
        }
        // Otherwise, fetch from network
        try {
          const response = await fetch(request);
          // Don't cache responses with error status codes
          if (!response || response.status !== 200 || response.type !== 'basic') {
            return response;
          }
          // Clone the response to save it to cache
          const responseToCache = response.clone();
          caches.open(CACHE_NAME)
            .then((cache) => {
              cache.put(request, responseToCache);
            });
          return response;
        } catch (error) {
          console.error('Fetch failed; returning offline page instead.', error);
          return new Response('Network error happened', {
            status: 408,
            headers: { 'Content-Type': 'text/plain' },
          });
        }
      })()
    );
  }
});
`;

      // Write the service worker file
      await fs.writeFile(swDest, content, "utf-8");
      console.log("Service worker generated at:", swDest);
    },
  };
}
